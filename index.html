<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Game - High Performance Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; object-fit: contain; transform: scaleX(-1); }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; color: white; text-shadow: 2px 2px 4px #000;
        }
        .info-container {
            position: absolute; top: 10px; left: 20px;
            display: flex; flex-direction: column; gap: 5px;
        }
        .info { font-size: 36px; font-weight: bold; }
        #score { color: #0f0; }
        #timer { color: #f00; }
        #msg { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 32px; text-align: center; color: #0f0;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>

    <video id="input_video" style="display:none" playsinline></video>
    <canvas id="output_canvas"></canvas>
    
    <div id="ui-layer">
        <div class="info-container">
            <div id="score" class="info">Score: 0</div>
            <div id="timer" class="info">Time: 40</div>
        </div>
        <div id="msg">カメラを起動中...</div>
    </div>

<script>
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const canvasCtx = canvasElement.getContext('2d');
const scoreElement = document.getElementById('score');
const timerElement = document.getElementById('timer');
const msgElement = document.getElementById('msg');

let score = 0;
let gameStarted = false;
let startTime = 0;
const gameDuration = 40; 
let countdown = gameDuration;

let fpo1x = 0.5, fpo1y = 0.5; 
let hiritu = 1.0;
let currentCount = 1;
let circles = [];
const circleRadius = 50;

let canScore = true;
let hasClosedMouth = true;
let isCoolDown = false;

let audioCtx = null;

const speech = window.speechSynthesis;
function speak(text) {
    if (speech.speaking) speech.cancel();
    const uttr = new SpeechSynthesisUtterance(text);
    uttr.lang = 'ja-JP';
    speech.speak(uttr);
}

// 0.2秒の軽やかな正解音
function beep() {
    try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(1000, audioCtx.currentTime);
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        osc.start(now);
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.2, now + 0.02);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
        osc.stop(now + 0.2);
    } catch(e) { console.error(e); }
}

function initCircles() {
    const positions = [
        {x: 80, y: 70}, {x: 320, y: 70}, {x: 560, y: 70},
        {x: 80, y: 210}, {x: 560, y: 210},
        {x: 80, y: 350}, {x: 320, y: 350}, {x: 560, y: 350}
    ];
    let nums = [1, 2, 3, 4, 5, 6, 7, 8].sort(() => Math.random() - 0.5);
    circles = positions.map((p, i) => ({ ...p, num: nums[i], active: true }));
}

function onResults(results) {
    // 描画負荷軽減のため、ビデオのサイズに合わせる
    if (canvasElement.width !== videoElement.videoWidth) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
    }

    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];
        const w = canvasElement.width;
        const h = canvasElement.height;

        // FaceMeshでの座標取得（Holisticと同じインデックスを使用可能）
        hiritu = (landmarks[152].y - landmarks[10].y) / 0.35; // 顔の縦幅で比率計算
        const po1x = landmarks[1].x;
        const po1y = landmarks[1].y;

        const xx = 0.5 - (fpo1x - po1x) * 4; 
        const relativeY = 0.5 - (fpo1y - po1y) * 6; 
        
        let thresholdMultiplier = 0.015 - (Math.max(0, Math.min(1, relativeY)) * 0.008);
        const mouthOpen = (landmarks[14].y - landmarks[13].y) > thresholdMultiplier * hiritu;

        // 鼻のグラフィック描画
        const noseDiameter = Math.abs(landmarks[195].y - landmarks[94].y) * h;
        const noseRadius = noseDiameter / 2;
        canvasCtx.fillStyle = mouthOpen ? "red" : "yellow"; 
        canvasCtx.beginPath();
        canvasCtx.arc(landmarks[4].x * w, landmarks[4].y * h, noseRadius, 0, 2 * Math.PI);
        canvasCtx.fill();

        if (!mouthOpen) {
            canScore = true;
            hasClosedMouth = true;
        }

        if (!gameStarted) {
            if (isCoolDown) {
                msgElement.innerText = "終了！ スコア: " + score + "\n少々お待ちください...";
            } else if (!hasClosedMouth) {
                msgElement.innerText = "一度口を閉じてください";
            } else {
                msgElement.innerText = "口を開けてスタート！\n(終了はEscキー)";
                if (mouthOpen) {
                    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioCtx.state === 'suspended') audioCtx.resume();
                    fpo1x = landmarks[1].x;
                    fpo1y = landmarks[1].y;
                    gameStarted = true;
                    startTime = Date.now();
                    score = 0;
                    currentCount = 1;
                    canScore = false; 
                    initCircles();
                    speak("スタート");
                    scoreElement.innerText = `Score: 0`;
                }
            }
        } else {
            msgElement.innerText = "";
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            countdown = Math.max(0, gameDuration - elapsed);
            timerElement.innerText = `Time: ${countdown}`;

            if (countdown <= 0) {
                gameStarted = false;
                hasClosedMouth = false;
                isCoolDown = true;
                speak(score + "点です。終了");
                setTimeout(() => { isCoolDown = false; }, 3000);
            }

            const cursorX = xx * w;
            const cursorY = relativeY * h;

            circles.forEach(c => {
                if (!c.active) return;
                canvasCtx.save();
                canvasCtx.globalAlpha = 0.8; 
                canvasCtx.beginPath();
                canvasCtx.arc(c.x, c.y, circleRadius, 0, 2 * Math.PI);
                canvasCtx.fillStyle = "red";
                canvasCtx.fill();
                
                canvasCtx.save();
                canvasCtx.scale(-1, 1); 
                canvasCtx.fillStyle = "white";
                canvasCtx.font = "bold 60px Arial";
                canvasCtx.textAlign = "center";
                canvasCtx.textBaseline = "middle";
                canvasCtx.fillText(c.num, -c.x, c.y);
                canvasCtx.restore();
                canvasCtx.restore();

                const dist = Math.sqrt((cursorX - c.x)**2 + (cursorY - c.y)**2);
                if (dist < circleRadius && mouthOpen && canScore && c.num === currentCount) {
                    c.active = false;
                    score++;
                    currentCount++;
                    canScore = false; 
                    scoreElement.innerText = `Score: ${score}`;
                    beep();
                }
            });

            if (currentCount > 8) {
                initCircles();
                currentCount = 1;
            }

            // カーソルの描画
            canvasCtx.beginPath();
            canvasCtx.arc(cursorX, cursorY, 72, 0, 2 * Math.PI);
            canvasCtx.strokeStyle = mouthOpen ? "#FF69B4" : "#00FF00"; 
            canvasCtx.lineWidth = 6;
            canvasCtx.stroke();
        }
    } else {
        if (gameStarted) msgElement.innerText = "顔が見つかりません";
    }
    canvasCtx.restore();
}

// FaceMeshの設定（Holisticより大幅に高速）
const faceMesh = new FaceMesh({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
});

faceMesh.setOptions({
    maxNumFaces: 1,
    refineLandmarks: false, // 高速化のため詳細設定をオフ
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

faceMesh.onResults(onResults);

const camera = new Camera(videoElement, {
    onFrame: async () => {
        await faceMesh.send({image: videoElement});
    },
    width: 640,
    height: 480
});
camera.start();

window.addEventListener('keydown', (e) => {
    if (e.key === "Escape") {
        gameStarted = false;
        speak("最初から");
        location.reload();
    }
});
</script>
</body>
</html>